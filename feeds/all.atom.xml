<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Power Up</title><link href="http://linpower.github.io/" rel="alternate"></link><link href="http://linpower.github.io/feeds/all.atom.xml" rel="self"></link><id>http://linpower.github.io/</id><updated>2015-12-29T13:34:38+08:00</updated><entry><title>Leetcode做题笔记</title><link href="http://linpower.github.io/leetcodezuo-ti-bi-ji.html" rel="alternate"></link><updated>2015-12-29T13:34:38+08:00</updated><author><name>power</name></author><id>tag:linpower.github.io,2015-12-29:leetcodezuo-ti-bi-ji.html</id><summary type="html">&lt;h2&gt;Two Sum&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The return numbers in vector should be increasely order.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Longest Substring Without Repeating Characters&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Record the position of every characters so far.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Median of Two Sorted Arrays&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Use the method of findKth&lt;/li&gt;
&lt;li&gt;The start index should add to k&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Longest Palindromic Substring&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Use Manacher algorithm.&lt;a href="http://articles.leetcode.com/2011/11/longest-palindromic-substring-part-ii.htm"&gt;reference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Time complexity O(N): the inner loop will take at most a total of N steps in the whole process. Why? Every step of outter loop, the mx(=id+len[id]) will be the most right index before this iteration and the inner loop will start checking charachers at position mx. Then update the mx. So the inner Loop will check every characher once.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Reverse Integer&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Use the type of &lt;code&gt;unsigned int&lt;/code&gt; to contain the &lt;code&gt;abs(x)&lt;/code&gt;, &lt;code&gt;sign&lt;/code&gt; be the sign of x.&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;res&lt;/code&gt; to represent the reverse result so far and &lt;code&gt;res = res * 10 + digit&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;When the &lt;code&gt;res&lt;/code&gt; is bigger than 214748364 and there is digit which do not reverse yet, it will be overflow. If the reverse is overflow, the reverse of digits exclude the fast digit of x must bigger than &lt;code&gt;((2 &amp;lt;&amp;lt; 31) - 1) &amp;gt;&amp;gt; 1&lt;/code&gt;. Because if x have nine digits, then the most significant digit should be 1 or 2.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;String to Integer (atoi)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;a href="http://www.cplusplus.com/reference/cstdlib/atoi/"&gt;atoi reference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Use &lt;a href="http://www.cplusplus.com/reference/cctype/isspace/"&gt;&lt;code&gt;int isspace(int c)&lt;/code&gt;&lt;/a&gt; to check if character is a white-space and &lt;a href="http://www.cplusplus.com/reference/cctype/isdigit/"&gt;&lt;code&gt;bool isdigit(char)&lt;/code&gt;&lt;/a&gt; to check if character is decimal digit.&lt;/li&gt;
&lt;li&gt;And according to the problem, it requires that if the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned. But the &lt;code&gt;atoi&lt;/code&gt; in standard library does not have this requirement.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Palindrome Number&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The negative integer is not a palindrome.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Regular Expression Matching&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;DP, O(n * m)&lt;/li&gt;
&lt;li&gt;f[i][j] = f[i-1][j-1] &amp;amp;&amp;amp; match(s[j], p[i]), if &lt;code&gt;p[i] != '*' &amp;amp;&amp;amp; p[i+1] != '*'&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;f[i][j] = f[i][j-1] || f[i-1][j-1] &amp;amp;&amp;amp; match(s[j], p[i]), if &lt;code&gt;p[i+1] == '*'&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;f[i][j] = f[i-1][j], if &lt;code&gt;p[i] == '*'&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Container With Most Water&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/lccycc/leetcode/blob/master/Container%20With%20Most%20Water.cpp"&gt;Reference lccycc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;assume that 0..i-1 and j+1..n-1 have all find their best match&lt;/li&gt;
&lt;li&gt;assume height[i] &amp;lt; height[j]&lt;/li&gt;
&lt;li&gt;if i match some k, i&amp;lt;k&amp;lt;j&lt;/li&gt;
&lt;li&gt;answer = (k-i) * min(height[i], height[k]) &amp;lt;= (k-i) * height[i] &amp;lt; (j-i) * height[i];&lt;/li&gt;
&lt;li&gt;so the best match of i is j.  for k &amp;lt; i or k &amp;gt; j, they have find their best match. so no need to concern.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Implement strStr()&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;kmp&lt;/li&gt;
&lt;li&gt;if the needle is empty string, should return 0.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Substring with Concatenation of All Words&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;O(len * n / len * len) = O(n * len), &lt;code&gt;n&lt;/code&gt; is the length of s, &lt;code&gt;m&lt;/code&gt; is the number of words, &lt;code&gt;len&lt;/code&gt; is the length of word.&lt;/li&gt;
&lt;li&gt;The straightforward thought is that we can scan every m * len long string start form each position in s and see if all the strings in words have been appeared only once using map data structure.&lt;/li&gt;
&lt;li&gt;How to pick every m * len long string? Pick a start position in [0, len-1] and get the m * len start with it. When we have a m * len long string and the range is [i, j], then we can get another m * len long string by removing the [i, i+len-1] chars and append [j+1, j+len] chars.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Longest Valid Parentheses&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;First push -1 into stack.&lt;/li&gt;
&lt;li&gt;Then Scan the s, when the char scaned now is &lt;code&gt;(&lt;/code&gt; then push the index into stack. When the char is &lt;code&gt;)&lt;/code&gt;, pop the top element if the number of element in stack is more than one or change the top element to be the index now if the stack only contains one element, and calculate the &lt;code&gt;i - top&lt;/code&gt; which is one of the candidates of the longest length.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Multiply Strings&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Leading zero should be removed.&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Leetcode"></category><category term="Notes"></category></entry><entry><title>Ubuntu出现相同图标</title><link href="http://linpower.github.io/ubuntuchu-xian-xiang-tong-tu-biao.html" rel="alternate"></link><updated>2015-12-29T13:33:47+08:00</updated><author><name>power</name></author><id>tag:linpower.github.io,2015-12-29:ubuntuchu-xian-xiang-tong-tu-biao.html</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;不知道什么时候误操作，导致dash里出现两个chrome图标：chrome图标，chrome打开新窗口图标。而且如果把第一个图标锁定到启动器，每次打开它又会产生第二个图标，神烦。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;原因&lt;/h2&gt;
&lt;p&gt;原因就是，不知道什么时候，在用户的目录下创建了一个chrome打开新窗口图标的图标，使得系统中存在两个chrome图标。&lt;/p&gt;
&lt;h2&gt;解决方法&lt;/h2&gt;
&lt;p&gt;将&lt;code&gt;~/.local/share/applications/google-chrome.desktop&lt;/code&gt;删除掉，这样就仅保留系统全局的chrome图标。&lt;/p&gt;</summary><category term="Ubuntu"></category></entry></feed>